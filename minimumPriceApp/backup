from rest_framework.decorators import api_view, permission_classes, parser_classes
from rest_framework.permissions import AllowAny
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.response import Response
from rest_framework import status, serializers
import pandas as pd
import numpy as np
from django.http import HttpResponse
from io import BytesIO
import os

@api_view(['GET', 'POST'])
@permission_classes([AllowAny])
def hello_rest_api(request):
    data = {'message': 'Hello, REST API!'}
    print(data)
    return Response(data)

class ExcelDataSerializer(serializers.Serializer):
    def to_representation(self, instance):
        """커스텀 직렬화"""
        data = {}
        for key, value in instance.items():
            if pd.isna(value) or np.isinf(value) if isinstance(value, (int, float)) else False:
                data[key] = None
            elif isinstance(value, (np.int_, np.intc, np.intp, np.int8, np.int16, np.int32, np.int64)):
                data[key] = int(value)
            elif isinstance(value, (np.float64, np.float16, np.float32, np.float64)):
                if np.isnan(value) or np.isinf(value):
                    data[key] = None
                else:
                    data[key] = float(value)
            else:
                data[key] = value
        return data

@api_view(['POST'])
@permission_classes([AllowAny])
@parser_classes([MultiPartParser, FormParser])
def upload_excel(request):
    if 'excel_file' not in request.FILES:
        return Response({'error': 'No file provided'}, status=status.HTTP_400_BAD_REQUEST)
    
    excel_file = request.FILES['excel_file']
    
    try:
        df = pd.read_excel(excel_file)
        
        # Serializer로 안전하게 처리
        serializer = ExcelDataSerializer()
        sample_data = []
        
        for _, row in df.head(10).iterrows():
            row_data = serializer.to_representation(row.to_dict())
            sample_data.append(row_data)
        
        return Response({
            'message': 'File uploaded successfully',
            'total_rows': len(df),
            'columns': df.columns.tolist(),
            'sample_data': sample_data,
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
    
# def validate_row(row_dict):
#     """
#     행 데이터 검증 함수 예제
#     실제 비즈니스 로직에 맞게 수정하세요
#     """
#     # 예제: 필수 필드 체크
#     required_fields = ['name', 'email']  # 실제 컬럼명으로 변경
    
#     for field in required_fields:
#         if field in row_dict and pd.isna(row_dict[field]):
#             return False
    
#     return True    

def clean_dataframe_for_json(df):
    """DataFrame을 JSON 직렬화 가능하도록 정리"""
    df_clean = df.copy()
    df_clean = df_clean.replace([np.inf, -np.inf], np.nan)
    
    numeric_columns = df_clean.select_dtypes(include=[np.number]).columns
    df_clean[numeric_columns] = df_clean[numeric_columns].fillna(0)
    
    string_columns = df_clean.select_dtypes(include=['object']).columns
    df_clean[string_columns] = df_clean[string_columns].fillna('')
    
    date_columns = df_clean.select_dtypes(include=['datetime64']).columns
    for col in date_columns:
        df_clean[col] = df_clean[col].dt.strftime('%Y-%m-%d %H:%M:%S').fillna('')
    
    return df_clean

@api_view(['POST'])
@permission_classes([AllowAny])
@parser_classes([MultiPartParser, FormParser])
def process_excel_and_download(request):
    """엑셀 파일을 처리하고 수정된 파일을 다운로드용으로 반환"""
    if 'excel_file' not in request.FILES:
        return Response({'error': 'No file provided'}, status=status.HTTP_400_BAD_REQUEST)
    
    excel_file = request.FILES['excel_file']
    
    try:
        # 엑셀 파일 읽기 (첫 번째 행을 헤더로 사용하지 않음)
        df = pd.read_excel(excel_file, header=None)
        
        # 원본 데이터 정보
        original_info = {
            'total_rows': len(df),
            'columns': df.columns.tolist(),
        }
        
        # column 6 (인덱스 5 또는 6번째 컬럼)에 +50 추가 (단, row 6부터만)
        if len(df.columns) > 5:  # 6번째 컬럼이 존재하는지 확인
            column_index = 5  # 6번째 컬럼 (0부터 시작하므로 인덱스 5)
            
            # row 6부터만 처리 (인덱스 5부터, 0부터 시작하므로)
            for row_idx in range(5, len(df)):  # row 6부터 (인덱스 5부터)
                try:
                    # 현재 값이 숫자인지 확인하고 처리
                    current_value = df.iloc[row_idx, column_index]
                    if pd.notna(current_value):
                        # 숫자로 변환 시도
                        numeric_value = pd.to_numeric(current_value, errors='coerce')
                        if pd.notna(numeric_value):
                            df.iloc[row_idx, column_index] = numeric_value + 50
                except Exception:
                    # 변환할 수 없는 경우 그대로 유지
                    continue
        else:
            return Response({'error': 'File does not have 6 columns'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        # 수정된 파일을 메모리에 저장
        output = BytesIO()
        
        # 원본 파일 확장자에 따라 저장 방식 결정
        file_extension = os.path.splitext(excel_file.name)[1].lower()
        
        if file_extension == '.csv':
            df.to_csv(output, index=False, encoding='utf-8-sig')
            content_type = 'text/csv'
            file_name = f"modified_{excel_file.name}"
        else:
            # Excel 파일로 저장
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name='Sheet1')
            content_type = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            file_name = f"modified_{os.path.splitext(excel_file.name)[0]}.xlsx"
        
        output.seek(0)
        
        # 파일 다운로드 응답
        response = HttpResponse(
            output.getvalue(),
            content_type=content_type
        )
        response['Content-Disposition'] = f'attachment; filename="{file_name}"'
        response['Content-Length'] = str(len(output.getvalue()))
        
        # CORS 헤더 추가
        response['Access-Control-Allow-Origin'] = '*'  # 실제 운영에서는 특정 도메인으로 설정
        response['Access-Control-Expose-Headers'] = 'Content-Disposition, Content-Length'
        
        return response
        
    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
@permission_classes([AllowAny])
@parser_classes([MultiPartParser, FormParser])
def process_excel_with_preview(request):
    """엑셀 파일을 처리하고 미리보기 + 다운로드 링크 제공"""
    if 'excel_file' not in request.FILES:
        return Response({'error': 'No file provided'}, status=status.HTTP_400_BAD_REQUEST)
    
    excel_file = request.FILES['excel_file']
    
    try:
        # 엑셀 파일 읽기 (첫 번째 행을 헤더로 사용하지 않음)
        df_original = pd.read_excel(excel_file, header=None)
        df_modified = df_original.copy()
        
        # column 6에 +50 추가 (단, row 6부터만)
        if len(df_modified.columns) > 5:
            column_index = 5  # 6번째 컬럼 (0부터 시작하므로 인덱스 5)
            
            # row 6부터만 처리 (인덱스 5부터, 0부터 시작하므로)
            for row_idx in range(5, len(df_modified)):  # row 6부터 (인덱스 5부터)
                try:
                    current_value = df_modified.iloc[row_idx, column_index]
                    if pd.notna(current_value):
                        # 숫자로 변환 시도
                        numeric_value = pd.to_numeric(current_value, errors='coerce')
                        if pd.notna(numeric_value):
                            df_modified.iloc[row_idx, column_index] = numeric_value + 50
                except Exception:
                    # 변환할 수 없는 경우 그대로 유지
                    continue
        else:
            return Response({'error': 'File does not have 6 columns'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        # JSON 직렬화를 위한 데이터 정리
        df_original_clean = clean_dataframe_for_json(df_original)
        df_modified_clean = clean_dataframe_for_json(df_modified)
        
        return Response({
            'message': 'File processed successfully',
            'column_modified': f'Column 6 (from row 6 onwards)',
            'total_rows': len(df_modified),
            'columns': [f'Column_{i+1}' for i in range(len(df_modified.columns))],  # 일반적인 컬럼명 생성
            'original_sample': df_original_clean.head(10).to_dict('records'),
            'modified_sample': df_modified_clean.head(10).to_dict('records'),
            'download_url': '/api/process-excel-download/',  # 실제 다운로드 엔드포인트
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)